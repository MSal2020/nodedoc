/// <reference types="./otpauth.d.ts" />
import*as c from"node:crypto";const H=i=>{const e=new ArrayBuffer(8),r=new Uint8Array(e);let t=i;for(let n=7;n>=0&&t!==0;n--)r[n]=t&255,t-=r[n],t/=256;return e};var T=void 0;const d=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})(),v={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},U=(i,e,r)=>{if(c!=null&&c.createHmac){const t=c.createHmac(i,d.Buffer.from(e));return t.update(d.Buffer.from(r)),t.digest().buffer}else{const t=v[i.toUpperCase()];if(typeof t=="undefined")throw new TypeError("Unknown hash function");const n=new T(t,"ARRAYBUFFER");return n.setHMACKey(e,"ARRAYBUFFER"),n.update(r),n.getHMAC("ARRAYBUFFER")}},I=(i,e)=>{let r="",t=e-String(i).length;for(;t-- >0;)r+="0";return`${r}${i}`},m="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",E=i=>{let e=i.length;for(;i[e-1]==="=";)--e;const r=(e<i.length?i.substring(0,e):i).toUpperCase(),t=new ArrayBuffer(r.length*5/8|0),n=new Uint8Array(t);let s=0,o=0,a=0;for(let u=0;u<r.length;u++){const g=m.indexOf(r[u]);if(g===-1)throw new TypeError(`Invalid character found: ${r[u]}`);o=o<<5|g,s+=5,s>=8&&(s-=8,n[a++]=o>>>s)}return t},B=i=>{const e=new Uint8Array(i);let r=0,t=0,n="";for(let s=0;s<e.length;s++)for(t=t<<8|e[s],r+=8;r>=5;)n+=m[t>>>r-5&31],r-=5;return r>0&&(n+=m[t<<5-r&31]),n},C=i=>{const e=new ArrayBuffer(i.length/2),r=new Uint8Array(e);for(let t=0;t<i.length;t+=2)r[t/2]=parseInt(i.substring(t,t+2),16);return e},O=i=>{const e=new Uint8Array(i);let r="";for(let t=0;t<e.length;t++){const n=e[t].toString(16);n.length===1&&(r+="0"),r+=n}return r.toUpperCase()},R=i=>{const e=new ArrayBuffer(i.length),r=new Uint8Array(e);for(let t=0;t<i.length;t++)r[t]=i.charCodeAt(t)&255;return e},P=i=>{const e=new Uint8Array(i);let r="";for(let t=0;t<e.length;t++)r+=String.fromCharCode(e[t]);return r},A=d.TextEncoder?new d.TextEncoder("utf-8"):null,y=d.TextDecoder?new d.TextDecoder("utf-8"):null,L=i=>{if(!A)throw new Error("Encoding API not available");return A.encode(i).buffer},x=i=>{if(!y)throw new Error("Encoding API not available");return y.decode(i)},j=i=>{if(c!=null&&c.randomBytes)return c.randomBytes(i).buffer;if(!d.crypto||!d.crypto.getRandomValues)throw new Error("Cryptography API not available");return d.crypto.getRandomValues(new Uint8Array(i)).buffer};class h{constructor(){let{buffer:e,size:r=20}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.buffer=typeof e=="undefined"?j(r):e}static fromLatin1(e){return new h({buffer:R(e)})}static fromUTF8(e){return new h({buffer:L(e)})}static fromBase32(e){return new h({buffer:E(e)})}static fromHex(e){return new h({buffer:C(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:P(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:x(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:B(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:O(this.buffer)}),this.hex}}const k=(i,e)=>{if(c!=null&&c.timingSafeEqual)return c.timingSafeEqual(d.Buffer.from(i),d.Buffer.from(e));{if(i.length!==e.length)throw new TypeError("Input strings must have the same length");let r=-1,t=0;for(;++r<i.length;)t|=i.charCodeAt(r)^e.charCodeAt(r);return t===0}};var F=Math.pow;let l=class{static get defaults(){return{issuer:"",label:"OTPAuth",algorithm:"SHA1",digits:6,counter:0,window:1}}constructor(){let{issuer:e=l.defaults.issuer,label:r=l.defaults.label,secret:t=new h,algorithm:n=l.defaults.algorithm,digits:s=l.defaults.digits,counter:o=l.defaults.counter}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.issuer=e,this.label=r,this.secret=typeof t=="string"?h.fromBase32(t):t,this.algorithm=n.toUpperCase(),this.digits=s,this.counter=o}static generate(e){let{secret:r,algorithm:t=l.defaults.algorithm,digits:n=l.defaults.digits,counter:s=l.defaults.counter}=e;const o=new Uint8Array(U(t,r.buffer,H(s))),a=o[o.byteLength-1]&15,u=((o[a]&127)<<24|(o[a+1]&255)<<16|(o[a+2]&255)<<8|o[a+3]&255)%F(10,n);return I(u,n)}generate(){let{counter:e=this.counter++}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return l.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){let{token:r,secret:t,algorithm:n,digits:s,counter:o=l.defaults.counter,window:a=l.defaults.window}=e;if(r.length!==s)return null;let u=null;for(let g=o-a;g<=o+a;++g){const p=l.generate({secret:t,algorithm:n,digits:s,counter:g});k(r,p)&&(u=g-o)}return u}validate(e){let{token:r,counter:t=this.counter,window:n}=e;return l.validate({token:r,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:n})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class f{static get defaults(){return{issuer:"",label:"OTPAuth",algorithm:"SHA1",digits:6,period:30,window:1}}constructor(){let{issuer:e=f.defaults.issuer,label:r=f.defaults.label,secret:t=new h,algorithm:n=f.defaults.algorithm,digits:s=f.defaults.digits,period:o=f.defaults.period}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.issuer=e,this.label=r,this.secret=typeof t=="string"?h.fromBase32(t):t,this.algorithm=n.toUpperCase(),this.digits=s,this.period=o}static generate(e){let{secret:r,algorithm:t,digits:n,period:s=f.defaults.period,timestamp:o=Date.now()}=e;return l.generate({secret:r,algorithm:t,digits:n,counter:Math.floor(o/1e3/s)})}generate(){let{timestamp:e=Date.now()}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return f.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate(e){let{token:r,secret:t,algorithm:n,digits:s,period:o=f.defaults.period,timestamp:a=Date.now(),window:u}=e;return l.validate({token:r,secret:t,algorithm:n,digits:s,counter:Math.floor(a/1e3/o),window:u})}validate(e){let{token:r,timestamp:t,window:n}=e;return f.validate({token:r,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:n})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const M=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,D=/^[2-7A-Z]+=*$/i,G=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,_=/^[+-]?\d+$/,b=/^\+?[1-9]\d*$/;class Y{static parse(e){let r;try{r=e.match(M)}catch(u){}if(!Array.isArray(r))throw new URIError("Invalid URI format");const t=r[1].toLowerCase(),n=r[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),s=r[3].split("&").reduce((u,g)=>{const p=g.split(/=(.*)/,2).map(decodeURIComponent),$=p[0].toLowerCase(),S=p[1],w=u;return w[$]=S,w},{});let o;const a={};if(t==="hotp")if(o=l,typeof s.counter!="undefined"&&_.test(s.counter))a.counter=parseInt(s.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(t==="totp"){if(o=f,typeof s.period!="undefined")if(b.test(s.period))a.period=parseInt(s.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(n.length===2?(a.label=n[1],a.issuer=n[0]):(a.label=n[0],typeof s.issuer!="undefined"&&(a.issuer=s.issuer)),typeof s.secret!="undefined"&&D.test(s.secret))a.secret=s.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof s.algorithm!="undefined")if(G.test(s.algorithm))a.algorithm=s.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof s.digits!="undefined")if(b.test(s.digits))a.digits=parseInt(s.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new o(a)}static stringify(e){if(e instanceof l||e instanceof f)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const Z="9.0.2";export{l as HOTP,h as Secret,f as TOTP,Y as URI,Z as version};
//# sourceMappingURL=otpauth.node.min.mjs.map
